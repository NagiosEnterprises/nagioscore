<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<title>Main Configuration File Options</title>

<STYLE type="text/css">
<!--
        .Default { font-family: verdana,arial,serif; font-size: 8pt; }
        .PageTitle { font-family: verdana,arial,serif; font-size: 12pt; font-weight: bold; }
-->      
</STYLE>

</head>

<body bgcolor="#FFFFFF" text="black" class="Default">

<p>
<div align="center">
<h2 class="PageTitle">Main Configuration File Options</h2>
</div>
</p>
<hr>

<p>
<strong><u>Notes</u></strong>
</p>
<p>
When creating and/or editing configuration files, keep the following in mind:
</p>
<p>
<ol>
<li>Lines that start with a '#' character are taken to be comments and are not processed
<li>Variables names must begin at the start of the line - no white space is allowed before the name
<li>Variable names are case-sensitive
</ol>
</p>

<p>
<strong><u>Sample Configuration</u></strong>
</p>
<p>
A sample main configuration file is created in the base directory of the Nagios distribution when you run the configure script.  The default name of the main configuration file is <b>nagios.cfg</b> - its usually placed in the <b>etc/</b> subdirectory of you Nagios installation (i.e. <i>/usr/local/nagios/etc/</i>).
</p>

<p>
<strong><u>Index</u></strong>
</p>
<p>
<a href="#log_file">Log file</a><br>
<a href="#cfg_file">Object configuration file</a><br>
<a href="#cfg_dir">Object configuration directory</a><br>
<a href="#object_cache_file">Object cache file</a><br>
<a href="#resource_file">Resource file</a><br>
<a href="#temp_file">Temp file</a><br>
<br>
<a href="#status_file">Status file</a><br>
<a href="#aggregate_status_updates">Aggregated status updates option</a><br>
<a href="#status_update_interval">Aggregated status data update interval</a><br>
<br>
<a href="#nagios_user">Nagios user</a><br>
<a href="#nagios_group">Nagios group</a><br>
<br>
<a href="#enable_notifications">Notifications option</a><br>
<a href="#execute_service_checks">Service check execution option</a><br>
<a href="#accept_passive_service_checks">Passive service check acceptance option</a><br>
<a href="#enable_event_handlers">Event handler option</a><br>
<br>
<a href="#log_rotation_method">Log rotation method</a><br>
<a href="#log_archive_path">Log archive path</a><br>
<br>
<a href="#check_external_commands">External command check option</a><br>
<a href="#command_check_interval">External command check interval</a><br>
<a href="#command_file">External command file</a><br>
<br>
<a href="#comment_file">Comment file</a><br>
<a href="#downtime_file">Downtime file</a><br>
<a href="#lock_file">Lock file</a><br>
<br>
<a href="#retain_state_information">State retention option</a><br>
<a href="#state_retention_file">State retention file</a><br>
<a href="#retention_update_interval">Automatic state retention update interval</a><br>
<a href="#use_retained_program_state">Use retained program state option</a><br>
<a href="#use_retained_scheduling_info">Use retained scheduling info option</a><br>
<br>
<a href="#use_syslog">Syslog logging option</a><br>
<a href="#log_notifications">Notification logging option</a><br>
<a href="#log_service_retries">Service check retry logging option</a><br>
<a href="#log_host_retries">Host retry logging option</a><br>
<a href="#log_event_handlers">Event handler logging option</a><br>
<a href="#log_initial_states">Initial state logging option</a><br>
<a href="#log_external_commands">External command logging option</a><br>
<a href="#log_passive_service_checks">Passive service check logging option</a><br>
<br>
<a href="#global_host_event_handler">Global host event handler</a><br>
<a href="#global_service_event_handler">Global service event handler</a><br>
<br>
<a href="#sleep_time">Inter-check sleep time</a><br>
<a href="#inter_check_delay_method">Inter-check delay method</a><br>
<a href="#service_interleave_factor">Service interleave factor</a><br>
<a href="#max_concurrent_checks">Maximum concurrent service checks</a><br>
<a href="#service_reaper_frequency">Service reaper frequency</a><br>
<a href="#interval_length">Timing interval length</a><br>
<br>
<a href="#use_agressive_host_checking">Agressive host checking option</a><br>
<br>
<a href="#enable_flap_detection">Flap detection option</a><br>
<a href="#low_service_flap_threshold">Low service flap threshold</a><br>
<a href="#high_service_flap_threshold">High service flap threshold</a><br>
<a href="#low_host_flap_threshold">Low host flap threshold</a><br>
<a href="#high_host_flap_threshold">High host flap threshold</a><br>
<br>
<a href="#soft_service_dependencies">Soft service dependencies option</a><br>
<br>
<a href="#service_check_timeout">Service check timeout</a><br>
<a href="#host_check_timeout">Host check timeout</a><br>
<a href="#event_handler_timeout">Event handler timeout</a><br>
<a href="#notification_timeout">Notification timeout</a><br>
<a href="#ocsp_timeout">Obsessive compulsive service processor timeout</a><br>
<a href="#ochp_timeout">Obsessive compulsive host processor timeout</a><br>
<a href="#perfdata_timeout">Performance data processor command timeout</a><br>
<br>
<a href="#obsess_over_services">Obsess over services option</a><br>
<a href="#ocsp_command">Obsessive compulsive service processor command</a><br>
<a href="#obsess_over_hosts">Obsess over hosts option</a><br>
<a href="#ochp_command">Obsessive compulsive host processor command</a><br>
<br>
<a href="#process_performance_data">Performance data processing option</a><br>
<br>
<a href="#check_for_orphaned_services">Orphaned service check option</a><br>
<br>
<a href="#check_service_freshness">Service freshness checking option</a><br>
<a href="#service_freshness_check_interval">Service freshness check interval</a><br>
<a href="#check_host_freshness">Host freshness checking option</a><br>
<a href="#host_freshness_check_interval">Host freshness check interval</a><br>
<br>
<a href="#date_format">Date format</a><br>
<br>
<a href="#illegal_object_name_chars">Illegal object name characters</a><br>
<a href="#illegal_macro_output_chars">Illegal macro output characters</a><br>
<br>
<a href="#admin_email">Administrator email address</a><br>
<a href="#admin_pager">Administrator pager</a><br>
</p>


<p>
<a name="log_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Log File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_file=/usr/local/nagios/var/nagios.log</strong></font></td>
</tr>
</table>
</p>

<p>
This variable specifies where Nagios should create its main log file.  This should be the first
variable that you define in your configuration file, as Nagios will try to write errors that it
finds in the rest of your configuration data to this file.  If you have <a href="#log_rotation_method">log rotation</a> enabled, this file will automatically be rotated every hour, day, week, or month.
</p>


<p>
<a name="cfg_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Object Configuration File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>cfg_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td>
<font color="red"><strong>cfg_file=/usr/local/nagios/etc/hosts.cfg</strong></font><br>
<font color="red"><strong>cfg_file=/usr/local/nagios/etc/services.cfg</strong></font><br>
<font color="red"><strong>cfg_file=/usr/local/nagios/etc/commands.cfg</strong></font>
</td>
</tr>
</table>
</p>

<p>
This directive is used to specify an <a href="configobject.html">object configuration file</a> containing object definitions that Nagios should use for monitoring.  Object configuration files contain definitions for hosts, host groups, contacts, contact groups, services, commands, etc.  You can seperate your configuration information into several files and specify multiple <b>cfg_file=</b> statements to have each of them processed.
</p>


<p>
<a name="cfg_dir"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Object Configuration Directory</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>cfg_dir=&lt;directory_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td>
<font color="red"><strong>cfg_dir=/usr/local/nagios/etc/commands</strong></font><br>
<font color="red"><strong>cfg_dir=/usr/local/nagios/etc/services</strong></font><br>
<font color="red"><strong>cfg_dir=/usr/local/nagios/etc/hosts</strong></font>
</td>
</tr>
</table>
</p>

<p>
This directive is used to specify a directory which contains <a href="configobject.html">object configuration files</a> that Nagios should use for monitoring.  All files in the directory with a <b>.cfg</b> extension are processed as object config files.  Additionally, Nagios will recursively process all config files in subdirectories of the directory you specify here.  You can seperate your configuration files into different directories and specify multiple <b>cfg_dir=</b> statements to have all config files in each directory processed.
</p>



<a name="object_cache_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Object Cache File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>object_cache_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td>
<font color="red"><strong>object_cache_file_file=/usr/local/nagios/var/objects.cache</strong></font>
</td>
</tr>
</table>
</p>

<p>
This directive is used to specify a file in which a cached copy of <a href="configobject.html">object definitions</a> should be stored.  The cache file is (re)created every time Nagios is (re)started and is used by the CGIs.   It is intended to speed up config file caching in the CGIs and allow you to edit the source <a href="#cfg_file">object config files</a> while Nagios is running without affecting the output displayed in the CGIs.
</p>


<p>
<a name="resource_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Resource File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>resource_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>resource_file=/usr/local/nagios/etc/resource.cfg</strong></font></td>
</tr>
</table>
</p>

<p>
This is used to specify an optional resource file that can contain $USERn$ <a href="macros.html">macro</a> definitions.  $USERn$ macros are useful for storing usernames, passwords, and items commonly used in command definitions (like directory paths).  The CGIs will <i>not</i> attempt to read resource files, so you can set restrictive permissions (600 or 660) on them to protect sensitive information.  You can include multiple resource files by adding multiple resource_file statements to the main config file - Nagios will process them all.  See the sample resource.cfg file in the base of the Nagios directory for an example of how to define $USERn$ macros.
</p>


<p>
<a name="temp_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Temp File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>temp_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>temp_file=/usr/local/nagios/var/nagios.tmp</strong></font></td>
</tr>
</table>
</p>

<p>
This is a temporary file that Nagios periodically creates to use when updating comment data, status data, etc.  The file is deleted when it is no longer needed.
</p>

<p>
<a name="status_file"></a>
<a name="status_log"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Status File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>status_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>status_file=/usr/local/nagios/var/status.dat</strong></font></td>
</tr>
</table>
</p>

<p>
This is the file that Nagios uses to store the current status of all monitored services.  The status of all hosts associated with the service you monitor are also recorded here.  This file is used by the CGIs so that current monitoring status can be reported via a web interface.  The CGIs must have read access to this file in order to function properly.  This file is deleted every time Nagios stops and recreated when it starts.
</p>


<p>
<a name="aggregate_status_updates"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Aggregated Status Updates Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>aggregate_status_updates=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>aggregate_status_updates=1</strong></font></td>
</tr>
</table>
</p>

<p>
This option determines whether or not Nagios will aggregate updates of host, service, and program status data.  If you do not enable this option, status data is updated every time a host or service checks occurs.  This can result in high CPU loads and file I/O if you are monitoring a lot of services.  If you want Nagios to only update status data (in the <a href="#status_file">status file</a>) every few seconds (as determined by the <a href="#status_update_interval">status_update_interval</a> option), enable this option.  If you want immediate updates, disable it.  I would highly recommend using aggregated updates (even at short intervals) unless you have good reason not to.  Values are as follows:
</p>
<p>
<ul>
<li>0 = Disable aggregated updates
<li>1 = Enabled aggregated updates (default)
</ul>
</p>



<p>
<a name="status_update_interval"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Aggregated Status Update Interval</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>status_update_interval=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>status_update_interval=15</strong></font></td>
</tr>
</table>
</p>

<p>
This setting determines how often (in seconds) that Nagios will update status data in the <a href="#status_file">status file</a>.  The minimum update interval is five seconds.  If you have disabled aggregated status updates (with the <a href="#aggregate_status_updates">aggregate_status_updates</a> option), this option has no effect.
</p>


<p>
<a name="nagios_user"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Nagios User</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>nagios_user=&lt;username/UID&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>nagios_user=nagios</strong></font></td>
</tr>
</table>
</p>

<p>
This is used to set the effective user that the Nagios process should run as.  After initial program startup and before starting to monitor anything, Nagios will drop its effective privileges and run as this user.  You may specify either a username or a UID.
</p>


<p>
<a name="nagios_group"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Nagios Group</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>nagios_group=&lt;groupname/GID&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>nagios_group=nagios</strong></font></td>
</tr>
</table>
</p>

<p>
This is used to set the effective group that the Nagios process should run as.  After initial program startup and before starting to monitor anything, Nagios will drop its effective privileges and run as this group.  You may specify either a groupname or a GID.
</p>


<p>
<a name="enable_notifications"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Notifications Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>enable_notifications=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>enable_notifications=1</strong></font></td>
</tr>
</table>
</p>

<p>
This option determines whether or not Nagios will send out <a href="notifications.html">notifications</a> when it initially (re)starts.  If this option is disabled, Nagios will not send out notifications for any host or service.  Note: If you have <a href="#retain_state_information">state retention</a> enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the <a href="#state_retention_file">state retention file</a>), <i>unless</i> you disable the <a href="#use_retained_program_state">use_retained_program_state</a> option.  If you want to change this option when state retention is active (and the <a href="#use_retained_program_state">use_retained_program_state</a> is enabled), you'll have to use the appropriate <a href="extcommands.html">external command</a> or change it via the web interface.  Values are as follows:
</p>
<p>
<ul>
<li>0 = Disable notifications
<li>1 = Enable notifications (default)
</ul>
</p>


<p>
<a name="execute_service_checks"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Service Check Execution Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>execute_service_checks=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>execute_service_checks=1</strong></font></td>
</tr>
</table>
</p>

<p>
This option determines whether or not Nagios will execute service checks when it initially (re)starts.  If this option is disabled, Nagios will not actively execute any service checks and will remain in a sort of "sleep" mode (it can still accept <a href="passivechecks.html">passive checks</a> unless you've <a href="#accept_passive_service_checks">disabled them</a>).   This option is most often used when configuring backup monitoring servers, as described in the documentation on <a href="redundancy.html">redundancy</a>, or when setting up a <a href="distributed.html">distributed</a> monitoring environment.  Note: If you have <a href="#retain_state_information">state retention</a> enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the <a href="#state_retention_file">state retention file</a>), <i>unless</i> you disable the <a href="#use_retained_program_state">use_retained_program_state</a> option.  If you want to change this option when state retention is active (and the <a href="#use_retained_program_state">use_retained_program_state</a> is enabled), you'll have to use the appropriate <a href="extcommands.html">external command</a> or change it via the web interface.  Values are as follows:
</p>
<p>
<ul>
<li>0 = Don't execute service checks
<li>1 = Execute service checks (default)
</ul>
</p>


<p>
<a name="accept_passive_service_checks"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Passive Service Check Acceptance Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>accept_passive_service_checks=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>accept_passive_service_checks=1</strong></font></td>
</tr>
</table>
</p>

<p>
This option determines whether or not Nagios will accept <a href="passivechecks.html">passive service checks</a> when it initially (re)starts.  If this option is disabled, Nagios will not accept any passive service checks.  Note: If you have <a href="#retain_state_information">state retention</a> enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the <a href="#state_retention_file">state retention file</a>), <i>unless</i> you disable the <a href="#use_retained_program_state">use_retained_program_state</a> option.  If you want to change this option when state retention is active (and the <a href="#use_retained_program_state">use_retained_program_state</a> is enabled), you'll have to use the appropriate <a href="extcommands.html">external command</a> or change it via the web interface.  Values are as follows:
</p>
<p>
<ul>
<li>0 = Don't accept passive service checks
<li>1 = Accept passive service checks (default)
</ul>
</p>


<p>
<a name="enable_event_handlers"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Event Handler Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>enable_event_handlers=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>enable_event_handlers=1</strong></font></td>
</tr>
</table>
</p>

<p>
This option determines whether or not Nagios will run <a href="eventhandlers.html">event handlers</a> when it initially (re)starts.  If this option is disabled, Nagios will not run any host or service event handlers.  Note: If you have <a href="#retain_state_information">state retention</a> enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the <a href="#state_retention_file">state retention file</a>), <i>unless</i> you disable the <a href="#use_retained_program_state">use_retained_program_state</a> option.  If you want to change this option when state retention is active (and the <a href="#use_retained_program_state">use_retained_program_state</a> is enabled), you'll have to use the appropriate <a href="extcommands.html">external command</a> or change it via the web interface.  Values are as follows:
</p>
<p>
<ul>
<li>0 = Disable event handlers
<li>1 = Enable event handlers (default)
</ul>
</p>


<p>
<a name="log_rotation_method"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Log Rotation Method</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_rotation_method=&lt;n/h/d/w/m&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_rotation_method=d</strong></font></td>
</tr>
</table>
</p>

<p>
This is the rotation method that you would like Nagios to use for your log file.  Values are as follows:
</p>
<p>
<ul>
<li>n = None (don't rotate the log - this is the default)
<li>h = Hourly (rotate the log at the top of each hour)
<li>d = Daily (rotate the log at midnight each day)
<li>w = Weekly (rotate the log at midnight on Saturday)
<li>m = Monthly (rotate the log at midnight on the last day of the month)
</ul>
</p>


<p>
<a name="log_archive_path"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Log Archive Path</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_archive_path=&lt;path&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_archive_path=/usr/local/nagios/var/archives/</strong></font></td>
</tr>
</table>
</p>

<p>
This is the directory where Nagios should place log files that have been rotated.  This option is ignored if you choose to not use the <a href="#log_rotation_method">log rotation</a> functionality.
</p>


<p>
<a name="check_external_commands"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>External Command Check Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>check_external_commands=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>check_external_commands=1</strong></font></td>
</tr>
</table>
</p>

<p>
This option determines whether or not Nagios will check the <a href="#command_file">command file</a> for internal commands it should execute.  This option must be enabled if you plan on using the <a href="cgis.html#command_cgi">command CGI</a> to issue commands via the web interface.  Third party programs can also issue commands to Nagios by writing to the command file, provided proper rights to the file have been granted as outlined in <a href="faqs.html#command_file_permissions">this FAQ</a>.  More information on external commands can be found <a href="extcommands.html">here</a>.
</p>
<p>
<ul>
<li>0 = Don't check external commands (default)
<li>1 = Check external commands
</ul>
</p>


<p>
<a name="command_check_interval"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>External Command Check Interval</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>command_check_interval=&lt;xxx&gt;[s]</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>command_check_interval=1</strong></font></td>
</tr>
</table>
</p>

<p>
If you specify a number with an "s" appended to it (i.e. 30s), this is the number of <i>seconds</i> to wait between external command checks.  If you leave off the "s", this is the number of "time units" to wait between external command checks. Unless you've changed the <a href="#interval_length">interval_length</a> value (as defined below) from the default value of 60, this number will mean minutes.  
</p>

<p>
Note: By setting this value to <b>-1</b>, Nagios will check for external commands as often as possible.  Each time Nagios checks for external commands it will read and process all commands present in the <a href="#command_file">command file</a> before continuing on with its other duties.  More information on external commands can be found <a href="extcommands.html">here</a>.
</p>


<p>
<a name="command_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>External Command File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>command_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>command_file=/usr/local/nagios/var/rw/nagios.cmd</strong></font></td>
</tr>
</table>
</p>

<p>
This is the file that Nagios will check for external commands to process.  The <a href="cgis.html#cmd_cgi">command CGI</a> writes commands to this file.  Other third party programs can write to this file if proper file permissions have been granted as outline in <a href="commandfile.html">here</a>.  The external command file is implemented as a named pipe (FIFO), which is created when Nagios starts and removed when it shuts down.  If the file exists when Nagios starts, the Nagios process will terminate with an error message.  More information on external commands can be found <a href="extcommands.html">here</a>.
</p>


<p>
<a name="downtime_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Downtime File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>downtime_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>downtime_file=/usr/local/nagios/var/downtime.dat</strong></font></td>
</tr>
</table>
</p>

<p>
This is the file that Nagios will use for storing scheduled host and service <a href="downtime.html">downtime</a> information.  Comments can be viewed and added for both hosts and services through the <a href="cgis.html#extinfo_cgi">extended information CGI</a>.
</p>


<p>
<a name="comment_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Comment File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>comment_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>comment_file=/usr/local/nagios/var/comment.dat</strong></font></td>
</tr>
</table>
</p>

<p>
This is the file that Nagios will use for storing service and host comments.  Comments can be viewed and added for both hosts and services through the <a href="cgis.html#extinfo_cgi">extended information CGI</a>.
</p>


<p>
<a name="lock_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Lock File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>lock_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>lock_file=/tmp/nagios.lock</strong></font></td>
</tr>
</table>
</p>

<p>
This option specifies the location of the lock file that Nagios should create when it runs as a daemon (when started with the -d command line argument).  This file contains the process id (PID) number of the running Nagios process.
</p>


<p>
<a name="retain_state_information"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>State Retention Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>retain_state_information=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>retain_state_information=1</strong></font></td>
</tr>
</table>
</p>

<p>
This option determines whether or not Nagios will retain state information for hosts and services between program restarts.  If you enable this option, you should supply a value for the <a href="#state_retention_file">state_retention_file</a> variable.  When enabled, Nagios will save all state information for hosts and service before it shuts down (or restarts) and will read in previously saved state information when it starts up again.
</p>
<p>
<ul>
<li>0 = Don't retain state information (default)
<li>1 = Retain state information
</ul>
</p>


<p>
<a name="state_retention_file"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>State Retention File</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>state_retention_file=&lt;file_name&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>state_retention_file=/usr/local/nagios/var/retention.dat</strong></font></td>
</tr>
</table>
</p>

<p>
This is the file that Nagios will use for storing service and host state information before it shuts down.  When Nagios is restarted it will use the information stored in this file for setting the initial states of services and hosts before it starts monitoring anything.  This file is deleted after Nagios reads in initial state information when it (re)starts.  In order to make Nagios retain state information between program restarts, you must enable the <a href="#retain_state_information">retain_state_information</a> option.
</p>


<p>
<a name="retention_update_interval"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Automatic State Retention Update Interval</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>retention_update_interval=&lt;minutes&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>retention_update_interval=60</strong></font></td>
</tr>
</table>
</p>

<p>
This setting determines how often (in minutes) that Nagios will automatically save retention data during normal operation.  If you set this value to 0, Nagios will not save retention data at regular intervals, but it will still save retention data before shutting down or restarting.  If you have disabled state retention (with the <a href="#retain_state_information">retain_state_information</a> option), this option has no effect.
</p>


<p>
<a name="use_retained_program_state"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Use Retained Program State Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>use_retained_program_state=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>use_retained_program_state=1</strong></font></td>
</tr>
</table>
</p>

<p>
This setting determines whether or not Nagios will set various program-wide state variables based on the values saved in the retention file.  Some of these program-wide state variables that are normally saved across program restarts if state retention is enabled include the <a href="#enable_notifications">enable_notifications</a>, <a href="#enable_flap_detection">enable_flap_detection</a>, <a href="#enable_event_handlers">enable_event_handlers</a>, <a href="#execute_service_checks">execute_service_checks</a>, and <a href="#accept_passive_service_checks">accept_passive_service_checks</a> options. If you do not have <a href="#retain_state_information">state retention</a> enabled, this option has no effect.
</p>
<p>
<ul>
<li>0 = Don't use retained program state
<li>1 = Use retained program state (default)
</ul>
</p>


<p>
<a name="use_retained_scheduling_info"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Use Retained Scheduling Info Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>use_retained_scheduling_info=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>use_retained_scheduling_info=1</strong></font></td>
</tr>
</table>
</p>

<p>
This setting determines whether or not Nagios will retain scheduling info (next check times) for hosts and services when it restarts.  If you are adding a large number (or percentage) of hosts and services, I would recommend disabling this option when you first restart Nagios.  Otherwise you will probably want to  leave it enabled.
</p>
<p>
<ul>
<li>0 = Don't use retained scheduling info
<li>1 = Use retained scheduling info (default)
</ul>
</p>


<p>
<a name="use_syslog"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Syslog Logging Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>use_syslog=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>use_syslog=1</strong></font></td>
</tr>
</table>
</p>

<p>
This variable determines whether messages are logged to the syslog facility on your local host.  Values
are as follows:
</p>
<p>
<ul>
<li>0 = Don't use syslog facility
<li>1 = Use syslog facility
</ul>
</p>


<p>
<a name="log_notifications"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Notification Logging Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_notifications=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_notifications=1</strong></font></td>
</tr>
</table>
</p>

<p>
This variable determines whether or not notification messages are logged.  If you have a lot of contacts
or regular service failures your log file will grow relatively quickly.  Use this option to keep contact
notifications from being logged.
</p>
<p>
<ul>
<li>0 = Don't log notifications
<li>1 = Log notifications
</ul>
</p>


<p>
<a name="log_service_retries"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Service Check Retry Logging Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_service_retries=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_service_retries=1</strong></font></td>
</tr>
</table>
</p>

<p>
This variable determines whether or not service check retries are logged.  Service check retries occur when a
service check results in a non-OK state, but you have configured Nagios to retry the service more than once before
responding to the error.  Services in this situation are considered to be in "soft" states.  Logging service check retries
is mostly useful when attempting to debug Nagios or test out service <a href="eventhandlers.html">event handlers</a>.
</p>
<p>
<ul>
<li>0 = Don't log service check retries
<li>1 = Log service check retries
</ul>
</p>


<p>
<a name="log_host_retries"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Host Check Retry Logging Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_host_retries=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_host_retries=1</strong></font></td>
</tr>
</table>
</p>

<p>
This variable determines whether or not host check retries are logged.  Logging host check retries
is mostly useful when attempting to debug Nagios or test out host <a href="eventhandlers.html">event handlers</a>.
</p>
<p>
<ul>
<li>0 = Don't log host check retries
<li>1 = Log host check retries
</ul>
</p>


<p>
<a name="log_event_handlers"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Event Handler Logging Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_event_handlers=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_event_handlers=1</strong></font></td>
</tr>
</table>
</p>

<p>
This variable determines whether or not service and host <a href="eventhandlers.html">event handlers</a> are logged.
Event handlers are optional commands that can be run whenever a service or hosts changes state.  Logging event handlers
is most useful when debugging Nagios or first trying out your event handler scripts.
</p>
<p>
<ul>
<li>0 = Don't log event handlers
<li>1 = Log event handlers
</ul>
</p>


<p>
<a name="log_initial_states"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Initial States Logging Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_initial_states=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_initial_states=1</strong></font></td>
</tr>
</table>
</p>

<p>
This variable determines whether or not Nagios will force all initial host and service states to be logged, even if they result in an OK state.  Initial service and host states are normally only logged when there is a problem on the first check.  Enabling this option is useful if you are using an application that scans the log file to determine long-term state statistics for services and hosts.
</p>
<p>
<ul>
<li>0 = Don't log initial states (default)
<li>1 = Log initial states
</ul>
</p>



<p>
<a name="log_external_commands"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>External Command Logging Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_external_commands=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_external_commands=1</strong></font></td>
</tr>
</table>
</p>

<p>
This variable determines whether or not Nagios will log <a href="extcommands.html">external commands</a> that it receives from the <a href="#command_file">external command file</a>.  Note: This option does not control whether or not <a href="passivechecks.html">passive service checks</a> (which are a type of external command) get logged.  To enable or disable logging of passive checks, use the <a href="#log_passive_service_checks">log_passive_service_checks</a> option.
</p>
<p>
<ul>
<li>0 = Don't log external commands
<li>1 = Log external commands (default)
</ul>
</p>




<p>
<a name="log_passive_service_checks"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Passive Service Check Logging Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>log_passive_service_checks=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>log_passive_service_checks=1</strong></font></td>
</tr>
</table>
</p>

<p>
This variable determines whether or not Nagios will log <a href="passivechecks.html">passive service checks</a> that it receives from the <a href="#command_file">external command file</a>.  If you are setting up a <a href="distributed.html">distributed monitoring environment</a> or plan on handling a large number of passive checks on a regular basis, you may wish to disable this option so your log file doesn't get too large.
</p>
<p>
<ul>
<li>0 = Don't log passive service checks
<li>1 = Log passive service checks (default)
</ul>
</p>



<p>
<a name="global_host_event_handler"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Global Host Event Handler Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>global_host_event_handler=&lt;command&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>global_host_event_handler=log-host-event-to-db</strong></font></td>
</tr>
</table>
</p>

<p>
This option allows you to specify a host event handler command that is to be run for every host state change.  The global event handler is executed immediately prior to the event handler that you have optionally specified in each host definition.  The <i>command</i> argument is the short name of a command that you define in your <a href="configobject.html">object configuration file</a>.  The maximum amount of time that this command can run is controlled by the <a href="#event_handler_timeout">event_handler_timeout</a> option.  More information on event handlers can be found <a href="eventhandlers.html">here</a>.
</p>


<p>
<a name="global_service_event_handler"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Global Service Event Handler Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>global_service_event_handler=&lt;command&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>global_service_event_handler=log-service-event-to-db</strong></font></td>
</tr>
</table>
</p>

<p>
This option allows you to specify a service event handler command that is to be run for every service state change.  The global event handler is executed immediately prior to the event handler that you have optionally specified in each service definition.  The <i>command</i> argument is the short name of a command that you define in your <a href="configobject.html">object configuration file</a>.  The maximum amount of time that this command can run is controlled by the <a href="#event_handler_timeout">event_handler_timeout</a> option.  More information on event handlers can be found <a href="eventhandlers.html">here</a>.
</p>


<p>
<a name="sleep_time"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Inter-Check Sleep Time</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>sleep_time=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>sleep_time=1</strong></font></td>
</tr>
</table>
</p>
This is the number of seconds that Nagios will sleep before checking to see if the next service check in the
scheduling queue should be executed.  Note that Nagios will only sleep after it "catches up" with queued 
service checks that have fallen behind.
</p>


<p>
<a name="inter_check_delay_method"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Inter-Check Delay Method</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>inter_check_delay_method=&lt;n/d/s/x.xx&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>inter_check_delay_method=s</strong></font></td>
</tr>
</table>
</p>
This option allows you to control how service checks are initially "spread out" in the event queue.  Using a "smart" delay calculation (the default) will cause Nagios to calculate an average check interval and spread initial checks of all services out over that interval, thereby helping to eliminate CPU load spikes.  Using no delay is generally <i>not</i> recommended unless you are testing the <a href="parallelization.html">service check parallelization</a> functionality.  Using no delay will cause all service checks to be scheduled for execution at the same time.  This means that you will generally have large CPU spikes when the services are all executed in parallel.   More information on how to estimate how the inter-check delay affects service check scheduling can be found <a href="checkscheduling.html#inter_check_delay">here</a>.Values are as follows:
</p>
<p>
<ul>
<li>n = Don't use any delay - schedule all service checks to run immediately (i.e. at the same time!)
<li>d = Use a "dumb" delay of 1 second between service checks
<li>s = Use a "smart" delay calculation to spread service checks out evenly (default)
<li>x.xx = Use a user-supplied inter-check delay of x.xx seconds
</ul>
</p>


<p>
<a name="service_interleave_factor"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Service Interleave Factor</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>service_interleave_factor=&lt;s|<i>x</i>&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>service_interleave_factor=s</strong></font></td>
</tr>
</table>
</p>

</p>
This variable determines how service checks are interleaved. Interleaving allows for a more even distribution of service checks, reduced load on <i>remote</i> hosts, and faster overall detection of host problems.  With the introduction of service check <a href="parallelization.html">parallelization</a>, remote hosts could get bombarded with checks if interleaving was not implemented.  This could cause the service checks to fail or return incorrect results if the remote host was overloaded with processing other service check requests.  Setting this value to 1 is equivalent to not interleaving the service checks (this is how versions of Nagios previous to 0.0.5 worked).  Set this value to <b>s</b> (smart) for automatic calculation of the interleave factor unless you have a specific reason to change it.  The best way to understand how interleaving works is to watch the <a href="cgis.html#status_cgi">status CGI</a> (detailed view) when Nagios is just starting.  You should see that the service check results are spread out as they begin to appear.  More information on how interleaving works can be found <a href="checkscheduling.html#service_interleaving">here</a>.
<ul>
<li><i>x</i> = A number greater than or equal to 1 that specifies the interleave factor to use.  An interleave factor of 1 is equivalent to not interleaving the service checks.
<li>s = Use a "smart" interleave factor calculation (default)
</ul>
</p>


<p>
<a name="max_concurrent_checks"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Maximum Concurrent Service Checks</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>max_concurrent_checks=&lt;max_checks&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>max_concurrent_checks=20</strong></font></td>
</tr>
</table>
</p>

</p>
This option allows you to specify the maximum number of service checks that can be run in <a href="parallelization.html">parallel</a> at any given time.  Specifying a value of 1 for this variable essentially prevents any service checks from being parallelized.  Specifying a value of 0 (the default) does not place any restrictions on the number of concurrent checks.  You'll have to modify this value based on the system resources you have available on the machine that runs Nagios, as it directly affects the maximum load that will be imposed on the system (processor utilization, memory, etc.).  More information on how to estimate how many concurrent checks you should allow can be found <a href="checkscheduling.html#max_concurrent_checks">here</a>.
</p>


<p>
<a name="service_reaper_frequency"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Service Reaper Frequency</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>service_reaper_frequency=&lt;frequency_in_seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>service_reaper_frequency=10</strong></font></td>
</tr>
</table>
</p>
This option allows you to control the frequency <i>in seconds</i> of service "reaper" events.  "Reaper" events process the results from <a href="parallelization.html">parallelized service checks</a> that have finished executing.  These events consitute the core of the monitoring logic in Nagios.
</p>


<p>
<a name="interval_length"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Timing Interval Length</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>interval_length=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>interval_length=60</strong></font></td>
</tr>
</table>
</p>
This is the number of seconds per "unit interval" used for timing in the scheduling queue, re-notifications, etc. "Units intervals" are used in the host configuration file to determine how often to run a service check, how often of re-notify a contact, etc.
</p>
<p>
<strong>Important:</strong>  The default value for this is set to 60, which means that a "unit value" of 1 in the host configuration file will mean 60 seconds (1 minute).  I have not really tested other values for this variable, so proceed at your own risk if you decide to do so!
</p>


<p>
<a name="use_agressive_host_checking"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Agressive Host Checking Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>use_agressive_host_checking=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>use_agressive_host_checking=0</strong></font></td>
</tr>
</table>
</p>
Nagios tries to be smart about how and when it checks the status of hosts.  In general, disabling this option will allow Nagios to make some smarter decisions and check hosts a bit faster.  Enabling this option will increase the amount of time required to check hosts, but may improve reliability a bit.  Unless you have problems with Nagios not recognizing that a host recovered, I would suggest <b>not</b> enabling this option.
</p>
<p>
<ul>
<li>0 = Don't use agressive host checking (default)
<li>1 = Use agressive host checking
</ul>
</p>




<p>
<a name="enable_flap_detection"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Flap Detection Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>enable_flap_detection=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>enable_flap_detection=0</strong></font></td>
</tr>
</table>
</p>
This option determines whether or not Nagios will try and detect hosts and services that are "flapping".  Flapping occurs when a host or service changes between states too frequently, resulting in a barrage of notifications being sent out.  When Nagios detects that a host or service is flapping, it will temporarily suppress notifications for that host/service until it stops flapping.  Flap detection is very experimental at this point, so use this feature with caution!  More information on how flap detection and handling works can be found <a href="flapping.html">here</a>.     Note: If you have <a href="#retain_state_information">state retention</a> enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the <a href="#state_retention_file">state retention file</a>), <i>unless</i> you disable the <a href="#use_retained_program_state">use_retained_program_state</a> option.  If you want to change this option when state retention is active (and the <a href="#use_retained_program_state">use_retained_program_state</a> is enabled), you'll have to use the appropriate <a href="extcommands.html">external command</a> or change it via the web interface.
</p>
<p>
<ul>
<li>0 = Don't enable flap detection (default)
<li>1 = Enable flap detection
</ul>
</p>


<p>
<a name="low_service_flap_threshold"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Low Service Flap Threshold</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>low_service_flap_threshold=&lt;percent&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>low_service_flap_threshold=25.0</strong></font></td>
</tr>
</table>
</p>
This option is used to set the low threshold for detection of service flapping.  For more information on how flap detection and handling works (and how this option affects things) read <a href="flapping.html">this</a>.
</p>


<p>
<a name="high_service_flap_threshold"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>High Service Flap Threshold</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>high_service_flap_threshold=&lt;percent&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>high_service_flap_threshold=50.0</strong></font></td>
</tr>
</table>
</p>
This option is used to set the low threshold for detection of service flapping.  For more information on how flap detection and handling works (and how this option affects things) read <a href="flapping.html">this</a>.
</p>


<p>
<a name="low_host_flap_threshold"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Low Host Flap Threshold</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>low_host_flap_threshold=&lt;percent&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>low_host_flap_threshold=25.0</strong></font></td>
</tr>
</table>
</p>
This option is used to set the low threshold for detection of host flapping.  For more information on how flap detection and handling works (and how this option affects things) read <a href="flapping.html">this</a>.
</p>


<p>
<a name="high_host_flap_threshold"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>High Host Flap Threshold</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>high_host_flap_threshold=&lt;percent&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>high_host_flap_threshold=50.0</strong></font></td>
</tr>
</table>
</p>
This option is used to set the low threshold for detection of host flapping.  For more information on how flap detection and handling works (and how this option affects things) read <a href="flapping.html">this</a>.
</p>


<p>
<a name="soft_service_dependencies"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Soft Service Dependencies Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>soft_state_dependencies=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>soft_state_dependencies=0</strong></font></td>
</tr>
</table>
</p>
This option determines whether or not Nagios will use soft service state information when checking <a href="dependencies.html">service dependencies</a>.  Normally Nagios will only use the latest hard service state when checking dependencies.  If you want it to use the latest state (regardless of whether its a soft or hard <a href="statetypes.html">state type</a>), enable this option.
</p>
<p>
<ul>
<li>0 = Don't use soft service state dependencies (default)
<li>1 = Use soft service state dependencies
</ul>
</p>


<p>
<a name="service_check_timeout"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Service Check Timeout</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>service_check_timeout=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>service_check_timeout=60</strong></font></td>
</tr>
</table>
</p>
This is the maximum number of seconds that Nagios will allow service checks to run.  If checks exceed this limit, they are killed and a CRITICAL state is returned.   A timeout error will also be logged.
</p>
<p>
There is often widespread confusion as to what this option really does.  It is meant to be used as a last ditch mechanism to kill off plugins which are misbehaving and not exiting in a timely manner.  It should be set to something high (like 60 seconds or more), so that each service check normally finishes executing within this time limit.  If a service check runs longer than this limit, Nagios will kill it off thinking it is a runaway processes.
</p>


<p>
<a name="host_check_timeout"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Host Check Timeout</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>host_check_timeout=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>host_check_timeout=60</strong></font></td>
</tr>
</table>
</p>
This is the maximum number of seconds that Nagios will allow host checks to run.  If checks exceed this limit, they are killed and a CRITICAL state is returned and the host will be assumed to be DOWN.  A timeout error will also be logged.
</p>
<p>
There is often widespread confusion as to what this option really does.  It is meant to be used as a last ditch mechanism to kill off plugins which are misbehaving and not exiting in a timely manner.  It should be set to something high (like 60 seconds or more), so that each host check normally finishes executing within this time limit.  If a host check runs longer than this limit, Nagios will kill it off thinking it is a runaway processes.
</p>


<p>
<a name="event_handler_timeout"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Event Handler Timeout</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>event_handler_timeout=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>event_handler_timeout=60</strong></font></td>
</tr>
</table>
</p>
This is the maximum number of seconds that Nagios will allow <a href="eventhandlers.html">event handlers</a> to be run.  If an event handler exceeds this time limit it will be killed and a warning will be logged.
</p>
<p>
There is often widespread confusion as to what this option really does.  It is meant to be used as a last ditch mechanism to kill off commands which are misbehaving and not exiting in a timely manner.  It should be set to something high (like 60 seconds or more), so that each event handler command normally finishes executing within this time limit.  If an event handler runs longer than this limit, Nagios will kill it off thinking it is a runaway processes.
</p>


<p>
<a name="notification_timeout"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Notification Timeout</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>notification_timeout=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>notification_timeout=60</strong></font></td>
</tr>
</table>
</p>
This is the maximum number of seconds that Nagios will allow notification commands to be run.  If a notification command exceeds this time limit it will be killed and a warning will be logged.
</p>
<p>
There is often widespread confusion as to what this option really does.  It is meant to be used as a last ditch mechanism to kill off commands which are misbehaving and not exiting in a timely manner.  It should be set to something high (like 60 seconds or more), so that each notification command finishes executing within this time limit.  If a notification command runs longer than this limit, Nagios will kill it off thinking it is a runaway processes.
</p>


<p>
<a name="ocsp_timeout"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Obsessive Compulsive Service Processor Timeout</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>ocsp_timeout=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>ocsp_timeout=5</strong></font></td>
</tr>
</table>
</p>
This is the maximum number of seconds that Nagios will allow an <a href="#ocsp_command">obsessive compulsive service processor command</a> to be run.  If a command exceeds this time limit it will be killed and a warning will be logged.
</p>


<p>
<a name="ochp_timeout"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Obsessive Compulsive Host Processor Timeout</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>ochp_timeout=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>ochp_timeout=5</strong></font></td>
</tr>
</table>
</p>
This is the maximum number of seconds that Nagios will allow an <a href="#ochp_command">obsessive compulsive host processor command</a> to be run.  If a command exceeds this time limit it will be killed and a warning will be logged.
</p>


<p>
<a name="perfdata_timeout"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Performance Data Processor Command Timeout</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>perfdata_timeout=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>perfdata_timeout=5</strong></font></td>
</tr>
</table>
</p>
This is the maximum number of seconds that Nagios will allow a <a href="#host_perfdata_command">host performance data processor command</a> or <a href="#service_perfdata_command">service performance data processor command</a> to be run.  If a command exceeds this time limit it will be killed and a warning will be logged.
</p>


<p>
<a name="obsess_over_services"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Obsess Over Services Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>obsess_over_services=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>obsess_over_services=1</strong></font></td>
</tr>
</table>
</p>
This value determines whether or not Nagios will "obsess" over service checks results and run the <a href="#ocsp_command">obsessive compulsive service processor command</a> you define.  I know - funny name, but it was all I could think of.  This option is useful for performing <a href="distributed.html">distributed monitoring</a>.  If you're not doing distributed monitoring, don't enable this option.
</p>
<p>
<ul>
<li>0 = Don't obsess over services (default)
<li>1 = Obsess over services
</ul>
</p>


<p>
<a name="ocsp_command"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Obsessive Compulsive Service Processor Command</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>ocsp_command=&lt;command&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>ocsp_command=obsessive_service_handler</strong></font></td>
</tr>
</table>
</p>

<p>
This option allows you to specify a command to be run after <i>every</i> service check, which can be useful in <a href="distributed.html">distributed monitoring</a>.  This command is executed after any <a href="eventhandlers.html">event handler</a> or <a href="notifications.html">notification</a> commands.  The <i>command</i> argument is the short name of a <a href="configobject.html#command">command definition</a> that you define in your host configuration file.  The maximum amount of time that this command can run is controlled by the <a href="#ocsp_timeout">ocsp_timeout</a> option.   More information on distributed monitoring can be found <a href="distributed.html">here</a>.  This command is only executed if the <a href="#obsess_over_services">obsess_over_services</a> option is enabled globally and if the <i>obsess_over_service</i> directive in the <a href="xodtemplate.html#service">service definition</a> is enabled.
</p>


<p>
<a name="obsess_over_hosts"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Obsess Over Hosts Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>obsess_over_hosts=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>obsess_over_hosts=1</strong></font></td>
</tr>
</table>
</p>
This value determines whether or not Nagios will "obsess" over host checks results and run the <a href="#ochp_command">obsessive compulsive host processor command</a> you define.  I know - funny name, but it was all I could think of.  This option is useful for performing <a href="distributed.html">distributed monitoring</a>.  If you're not doing distributed monitoring, don't enable this option.
</p>
<p>
<ul>
<li>0 = Don't obsess over hosts (default)
<li>1 = Obsess over hosts
</ul>
</p>


<p>
<a name="ochp_command"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Obsessive Compulsive Host Processor Command</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>ochp_command=&lt;command&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>ochp_command=obsessive_host_handler</strong></font></td>
</tr>
</table>
</p>

<p>
This option allows you to specify a command to be run after <i>every</i> host check, which can be useful in <a href="distributed.html">distributed monitoring</a>.  This command is executed after any <a href="eventhandlers.html">event handler</a> or <a href="notifications.html">notification</a> commands.  The <i>command</i> argument is the short name of a <a href="xodtemplate.html#command">command definition</a> that you define in your host configuration file.  The maximum amount of time that this command can run is controlled by the <a href="#ochp_timeout">ochp_timeout</a> option.   More information on distributed monitoring can be found <a href="distributed.html">here</a>.  This command is only executed if the <a href="#obsess_over_hosts">obsess_over_hosts</a> option is enabled globally and if the <i>obsess_over_host</i> directive in the <a href="xodtemplate.html#host">host definition</a> is enabled.
</p>


<p>
<a name="process_performance_data"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Performance Data Processing Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>process_performance_data=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>process_performance_data=1</strong></font></td>
</tr>
</table>
</p>
This value determines whether or not Nagios will process host and service check <a href="perfdata.html">performance data</a>.
</p>
<p>
<ul>
<li>0 = Don't process performance data (default)
<li>1 = Process performance data
</ul>
</p>


<p>
<a name="check_for_orphaned_services"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Orphaned Service Check Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>check_for_orphaned_services=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>check_for_orphaned_services=0</strong></font></td>
</tr>
</table>
</p>

<p>
This option allows you to enable or disable checks for orphaned service checks. Orphaned service checks are checks which ahve been executed and have been removed from the event queue, but have not had any results reported in a long time.  Since no results have come back in for the service, it is not rescheduled in the event queue.  This can cause service checks to stop being executed.  Normally it is very rare for this to happen - it might happen if an external user or process killed off the process that was being used to execute a service check.  If this option is enabled and Nagios finds that results for a particular service check have not come back, it will log an error message and reschedule the service check.  If you start seeing service checks that never seem to get rescheduled, enable this option and see if you notice any log messages about orphaned services.
</p>
<p>
<ul>
<li>0 = Don't check for orphaned service checks (default)
<li>1 = Check for orphaned service checks
</ul>
</p>


<p>
<a name="check_service_freshness"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Service Freshness Checking Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>check_service_freshness=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>check_service_freshness=0</strong></font></td>
</tr>
</table>
</p>

<p>
This option determines whether or not Nagios will periodically check the "freshness" of service checks.  Enabling this option is useful for helping to ensure that <a href="passivechecks.html">passive service checks</a> are received in a timely manner.  More information on freshness checking can be found <a href="freshness.html">here</a>.
</p>
<p>
<ul>
<li>0 = Don't check service freshness
<li>1 = Check service freshness (default)
</ul>
</p>


<p>
<a name="service_freshness_check_interval"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Service Freshness Check Interval</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>service_freshness_check_interval=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>service_freshness_check_interval=60</strong></font></td>
</tr>
</table>
</p>

<p>
This setting determines how often (in seconds) Nagios will periodically check the "freshness" of service check results.  If you have disabled service freshness checking (with the <a href="#check_service_freshness">check_service_freshness<a> option), this option has no effect.  More information on freshness checking can be found <a href="freshness.html">here</a>.
</p>


<p>
<a name="check_host_freshness"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Host Freshness Checking Option</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>check_host_freshness=&lt;0/1&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>check_host_freshness=0</strong></font></td>
</tr>
</table>
</p>

<p>
This option determines whether or not Nagios will periodically check the "freshness" of host checks.  Enabling this option is useful for helping to ensure that <a href="passivechecks.html">passive host checks</a> are received in a timely manner.  More information on freshness checking can be found <a href="freshness.html">here</a>.
</p>
<p>
<ul>
<li>0 = Don't check host freshness
<li>1 = Check host freshness (default)
</ul>
</p>


<p>
<a name="host_freshness_check_interval"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Host Freshness Check Interval</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>host_freshness_check_interval=&lt;seconds&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>host_freshness_check_interval=60</strong></font></td>
</tr>
</table>
</p>

<p>
This setting determines how often (in seconds) Nagios will periodically check the "freshness" of host check results.  If you have disabled host freshness checking (with the <a href="#check_h_freshostness">check_host_freshness<a> option), this option has no effect.  More information on freshness checking can be found <a href="freshness.html">here</a>.
</p>


<p>
<a name="date_format"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Date Format</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>date_format=&lt;option&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>date_format=us</strong></font></td>
</tr>
</table>
</p>
<p>
This option allows you to specify what kind of date/time format Nagios should use in the web interface and date/time <a href="macros.html">macros</a>.  Possible options (along with example output) include:
</p>
<p>
<table border="1" class="Default">
<tr><th>Option</th><th>Output Format</th><th>Sample Output</th></tr>
<tr><td>us</td><td>MM/DD/YYYY HH:MM:SS</td><td>06/30/2002 03:15:00</td></tr>
<tr><td>euro</td><td>DD/MM/YYYY HH:MM:SS</td><td>30/06/2002 03:15:00</td></tr>
<tr><td>iso8601</td><td>YYYY-MM-DD HH:MM:SS</td><td>2002-06-30 03:15:00</td></tr>
<tr><td>strict-iso8601</td><td>YYYY-MM-DDTHH:MM:SS</td><td>2002-06-30T03:15:00</td></tr>
</table>
</p>


<p>
<a name="illegal_object_name_chars"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Illegal Object Name Characters</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>illegal_object_name_chars=&lt;chars...&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>illegal_object_name_chars=`~!$%^&amp;*"|'&lt;&gt;?,()=</strong></font></td>
</tr>
</table>
</p>
<p>
This option allows you to specify illegal characters that cannot be used in host names, service descriptions, or names of other object types.  Nagios will allow you to use most characters in object definitions, but I recommend not using the characters shown in the example above.  Doing may give you problems in the web interface, notification commands, etc.
</p>


<p>
<a name="illegal_macro_output_chars"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Illegal Macro Output Characters</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>illegal_macro_output_chars=&lt;chars...&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>illegal_macro_output_chars=`~$^&amp;"|'&lt;&gt;</strong></font></td>
</tr>
</table>
</p>
<p>
This option allows you to specify illegal characters that should be stripped from <a href="macros.html">macros</a> before being used in notifications, event handlers, and other commands.  This DOES NOT affect macros used in service or host check commands.  You can choose to not strip out the characters shown in the example above, but I recommend you do not do this.  Some of these characters are interpreted by the shell (i.e. the backtick) and can lead to security problems.  The following macros are stripped of the characters you specify: 
</p>
<p>
<b>$HOSTOUTPUT$</b>, <b>$HOSTPERFDATA$</b>, <b>$HOSTACKAUTHOR$</b>, <b>$HOSTACKCOMMENT$</b>, <b>$SERVICEOUTPUT$</b>, <b>$SERVICEPERFDATA$</b>, <b>$SERVICEACKAUTHOR$</b>, and <b>$SERVICEACKCOMMENT$</b>
</p>


<p>
<a name="admin_email"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Administrator Email Address</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>admin_email=&lt;email_address&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>admin_email=root@localhost.localdomain</strong></font></td>
</tr>
</table>
</p>
This is the email address for the administrator of the local machine (i.e. the one that Nagios is running on).
This value can be used in notification commands by using the <b>$ADMINEMAIL$</b> <a href="macros.html">macro</a>.
</p>


<p>
<a name="admin_pager"></a>
<table border="0" width="100%" class="Default">
<tr>
<td bgcolor="#cbcbcb"><strong>Administrator Pager</strong></td>
</tr>
</table>
</p>

<p>
<table border="0" class="Default">
<tr>
<td>Format:</td>
<td><strong>admin_pager=&lt;pager_number_or_pager_email_gateway&gt;</strong></td>
</tr>
<tr>
<td>Example:</td>
<td><font color="red"><strong>admin_pager=pageroot@localhost.localdomain</strong></font></td>
</tr>
</table>
</p>
This is the pager number (or pager email gateway) for the administrator of the local machine (i.e. the one that Nagios is running on). The pager number/address can be used in notification commands by using the <b>$ADMINPAGER$</b> <a href="macros.html">macro</a>.
</p>


<hr>

</body>
</html>
